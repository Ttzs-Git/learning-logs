# python 基础语法

## 变量(变量指向特定的值;可修改;被赋值的标签)
### 命名规则
#### 字母(万国码,建议:英语)、数字、下划线;不能以数字打头——与C相同
#### 不能使用空格,可以使用下划线来分隔其中的单词;不要使用关键字和函数作为变量名
#### 惯例:变量名小写,多字母用下划线连接,私有变量下划线开头,受保护的变量单下划线开头
#### 尽量少用l和o
#### 原则:简短并且可描述

## 常量
### 没有内置的常量类型,建议使用:大写命名法,视为不变的量

### 

## 运算符
### 列表运算符([] [:])
### 为运算符(~ >> << & ^ |)
### 算数运算符( + - * / // % **)
### 比较运算符(== != <  >  <=  =>| 返回布尔值)
### 身份运算符(is  is not)
### 成员运算符(in not in)
### 逻辑运算符(and or not| 返回布尔值|短路处理)
### 赋值运算符(= += -= *= /= %= //= &/ |= ^= >>= <<=)

## 注释
### 原则: 清晰,简洁,便于合作和读写
### 注释——方案的描述——姓名,当前日期,功能

## 程序结构
### 顺序结构(自上而下地执行)
#### 1. 交换变量中的内容
##### a,b,c=c,b,a

### 分支结构
#### 1. if(条件测试|布尔表达式)..elif(条件测试)..else(:)
##### a. 嵌套循环
##### b.条件测试:数值0、空值None、单引号空字符串''、双引号空字符串""、空列表[]、空元组()、空字典{}，Python 都会返回False
#### 2. match(变量)...case(常量):xxx
##### a.基本模式:执行匹配的case后就跳出
##### b.合并模式: |

### 循环结构
#### 1. for ...in..(i/_通配符)
##### a. for ... in range()
##### b. for ... in items
##### c. 嵌套循环

#### 2. while
##### 交互性退出程序:while(flag):(flag) | while 条件: | while True: xxx: break

#### 3. break和continue

## 
#### 

#### 

### 

##### 

### 

## 内置函数
### 类型函数
#### type()函数: 对变量的类型进行检查
#### int()函数：
##### 1. 将一个数值(只取整数部分)转换成整数
##### 2. 将字符串(只能将数字字符直接转化成数字)转换成整数
##### 3. 可以指定进制进行理解
##### 4. True 为1,False 为0
#### bin()函数:整数转化为 0b开头的二进制字符串
#### hex()函数:整数转化为 0x开头的十六进制字符串
#### oct()函数:整数转化为 0o开头的八进制字符串
#### open()函数:打开一个文件并返回文件对象
#### float()函数:
##### 1. 整数直接转化为浮点数
##### 2. 浮点状的字符串转化为浮点数
#### str()函数:将指定的f对象转换成字符串形式,可以指定编码方式
#### chr()函数:整数（字符编码）--->unicode码对应的字符
#### ord()函数:字符------>对应的unicode码
#### bool()函数:
##### 1. 非零数都是True,0是False
##### 2. 字符串如果是''或者""就是F,如果是其他,就是T
#### list()函数:转化为列表类型
#### tuple()函数:转化为元组类型

### 输入输出函数
#### input(prompt(提示))函数:形参是字符串('xxx'或者字符串变量),返回值是字符串,经常和类型函数联用
#### print()函数
##### 输出范式print('字符串',变量,end(结束符)='\n',sep(分隔符)='',flush='false')
> flush:True立即刷新输出缓冲区,没有遇到换行符也立即将数据发送到输出设备-适合流式文本;False等待缓冲区满了再刷新-适合交互式文本


### 计算函数
#### abs()函数:返回绝对值
#### pow(a,b)函数:a**b
### round(a,b)函数:按照指定的精度对数值进行四舍五入,得到b位小数的四舍五入的值

### range()函数——构造一个范围序列
#### range(start,end,step)<=====>i = start;i<\end;i+=step
##### 省略规则: start=0| step=1 可省略

### 列表相关
#### list()函数——列表对象的构造器
#### filter(条件,列表)函数——实现对序列元素的过滤
#### map(函数,列表)函数——实现对序列元素的映射

### len()函数——获得列表的长度

### set()函数——集合对象的构造器
#### 创建一个空集合
#### 将其他序列转化为集合

### zip(a,b)函数——将两个序列压缩，并且建立映射关系

### dict()函数——字典对象的构造器
#### 直接使用'变量名=变量内容'的方式构造
#### dict(zip(a,b))，并建立映射关系(键值关系)

### sortd()函数
#### 不修改源列表,返回排序后的列表对象(函数的无副作用设计)
#### 范式sort(列表,key=函数)——函数定义排序

### all()函数-如果列表中的所有布尔值都是True,则返回True

### id() 函数——用于获取对象的“身份”，即该对象在内存中的唯一标识符,可能是逻辑地址

## 库(模块)
### 使用方法
#### 1. import 库(模块) (as 别名)   模块(库).函数
#### 2. from 库(模块) import 函数1,函数2    函数(直接使用)
#### 3. from 库(模块) import 函数 (as 别名)  
#### 4.form 库(模块) import *   函数(可以直接使用,不适用点号)——不建议使用

### time模块
#### time.sleep(n)函数:表示睡眠n秒(n可以是整形或者浮点型)

### re模块——正则表达式

### timeit模块
#### timeit.timeit('xxxx',number=n)函数--执行n次某步骤需要的花费时间

### random模块
#### random.random()函数———生成[0,1)范围之内的浮点数
#### random.randrange(a,b)函数——[a,b)范围之内的整数
#### random.sample(序列,k)函数——从列表|元组中不放回地抽取k个参数
#### random.choice(序列,k=n)函数——从列表|元组中随机抽取1个,又放回的抽样,参数k是一个命名关键字参数,在传参时必须指定参数名
#### random.randint(a,b)函数——返回一个整数N---a<=N<=b

### math 模块
#### math.factorial()函数——实现阶乘

### string模块
#### a.字符串常量(不需要括号)
##### I.string.digits-'0123456789'
##### II.string.ascii_letters-'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
##### III.string.ascii_uppercase-大写字母
##### IV.string.ascii_lowercase_小写字母

### statistics模块——统计信息

### operator模块
#### add()函数——加法
#### mul()函数——乘法

### functools模块
#### functools.reudce(运算函数,运算的数据,运算的初始值)——归约操作：列表转化为一个值
#### functools.partial
#### functools.wraps()——装饰器——装饰函数.\_\_wrapped\_\_()——得到修饰之前的函数
#### functools.lru_cache()——装饰器函数——避免递归工程中的大量重复运算

### sys模块
#### sys.setrecursionlimit(maxmize)函数——带参数有的修饰器函数,改变递归调用的最大深度,maxmize用来定义缓存空间的大小,默认值是128

### enum模块
#### enum.Enum类

## 自定义函数——某一项具体工作
### 1. 创建范式
#### def 函数名 (arg1(:类型),....)(->类型): 函数体  return 'sth'(否则,返回none) 
### 2. 参数
#### a.位置参数——函数(x,x,x)——参数必须关联到定义的形参的位置——顺序很重要
#### b.关键字参数——通过“参数名=参数值”的形式为函数传入参数——函数(形参n=x,形参m=y....)
#### c.强制位置参数--'\'--只能作为最后一个参数,必须按照顺序传参
#### d.命名关键字参数--'*'--只能作为第一个参数出现,必须按照匹配的方式传参
#### e.参数的默认值(定义函数时可以定义参数的默认值,带默认值的参数必须放在其他参数之后,可变参数表中不可有'\'，可以有'*')
#### f.参数:类型——————增加代码的可读性
#### g.可变参数——传入的参数的数量可变——使用星号表达式
##### I.*变量—保存到元组中-位置传参
##### II.*变量1,**变量2——(顺序)可变关键字参数传给变量2(参数名是键,参数值是值|变量2是字典),纯参数传给变量1,形成元组
##### III.普通变量,*args——第一个形参传给普通变量,可能存在的第二个,以及其他的传给变量args,形成元组
##### IV.普通变量,**kwargs——位置实参和不确定数量的关键字实参
##### V.普通变量,*args,**kwargs——普通变量,不确定数量的位置参数,不确定数量的关键字参数
#### h.列表参数
##### I.列表传入函数——对列表进行永久性地修改
##### II.副本列表参数   func(list\[:\])——不改变列表
### 3.模块module(文件)-完全限定名(模块名.函数名)
#### 范式1: import xxxx (as yyyy)  xxx.函数
#### 范式2: from xxxx import 函数 as(别名)
#### 注意:同名函数 以下为准
### 4.返回值-return :简单值|字典|列表
### 5.高阶函数——将函数作为参数传入函数,或者传出
### 6.Lambda函数(匿名函数):使用高阶函数的时候(参数或者返回值|一行代码|不考虑复用)
#### 范式:lambda x:f(x)
#### 7.偏函数——固定一些参数——鲁棒性分析??——新函数
##### functools.partial(函数,参数)
#### 8.装饰器:用一个函数装饰另外一个函数并为其提供额外的能力(嵌套定义函数——C表示羡慕的死死的)
##### I.使用装饰器函数的返回函数
##### II.语法糖——用@装饰器函数将装饰器函数直接放在被装饰的函数上
##### III.__wrapped__的求修饰
##### IV.修饰器函数本身可以可以参数化
#### 9.递归调用
##### 范式: 递归收敛条件+递归公式——if(收敛条件): xxx else:  函数()
##### 原理:(栈——先进后出)每进入一个函数调用,栈就会增加一层栈帧(stack frame),栈帧就是我们刚才提到的保存当前代码执行现场的结构:每当函数调用结束后,栈就会减少一层栈帧
##### 注意:递归调用一定要确保能够快速收敛,否则将会stackflow
##### CPython解释器——递归深度为1000
##### 如果无法实现快速递归,可以考虑循环递推(迭代)


## 异常处理(traceback包含异常的报告)(try-except代码块处理的)
### 常见异常及其可能原因
- `ZeroDivisionError`错误——除以0
- `nameerror`错误——未赋值;拼写错误
- `IndexError`错误——索引错误——解决:由于列表的动态变化,索引变化,打印出列表进行检查
- `ValueError`错误——查找不存在|元素个数和变量个数不匹配
- `TypeError`错误——类型错误——修改常量的数据|形参和实参不匹配
- `UnicodeDecodeError`错误-加解密方式不统一
- `KeyError`异常——索引健但缺少指定的值
- `SyntaxError`错误——语法错误——没有":";没有默认值的参数放在了带默认值的参数后面
- `RecursionError`错误———Stack Flow
- `AttributeError`异常——属性错误
- `IndentationError`错误--缩进错误
- ` FileNotFoundError`异常--try_except模块处理
### 异常处理语句:if-try-except-else代码块
#### 语句:try:xxx
 > 目的:尝试一些可能抛出异常的语句 

#### except 异常 as 变量: zzz ——(通过traceback编写|pass-保持静默)

- Exception:所有可能的异常
- 变量:将异常内容绑定到变量中，便于查看

#### else: 

## 处理数据常用方法: functools.reduce(归约),map(映射),filter(过滤)

## 编程范式
### 面向过程编程(OPP)
### 面向对象编程(OOP):定义类——创建对象——给对象发消息|数据抽象和行为抽象
#### 1.理解:
##### 0.总体
###### 把一组数据和处理数据的方法组成**对象**，把行为相同的对象归纳为**类**，通过**封装**隐藏对象的内部细节，通过**继承**实现类的特化和泛化，通过**多态**实现基于对象类型的动态分派
##### a.对象(object)
###### I.一组数据和处理数据的方法
###### II.面向对象的世界中,一切皆为对象
###### III. 对象的属性通常是私有(private)或者受保护(protected)的成员,方法通常是公开的(public)
##### b.类(class)
###### I.行为相同的对象的归纳
##### c.辩证关系:类是对象的蓝图和模板,对象是类的实例,是可以接受消息的实体,对象一定属于某一个类
#### 2.类
##### a.定义类
###### I.范式: class 类名(父类):  def 方法名(self,参数):---(方法是对象的行为,可以接受的消息)
##### b.静态方法和类方法——给类对象的消息                   
###### 范式:@staticmethmod 方法——静态方法
###### 范式:@classmethod 方法——类方法
###### 区别:对象方法调用的第一个参数:普通对象,类方法的第一个参数:类对象;静态方法的调用的第一个参数:没有接受消息的对象
##### c.装饰器@property 方法——像调用属性一样调用方法
##### d.方法之间的相互调用——范式:self.方法(参数)
#### 3.对象
##### a.实例化(创建对象)——构造器语法:变量名=类名(属性)——变量名实际是对象在内存中的逻辑位置
##### b.访问属性:  对象.属性
##### c.调用方法: 
###### I.范式1:类.方法(对象,方法的参数)
###### II.范式2:对象.方法(方法参数) 
##### d.属性的初始化
###### I.\_init\_(self,参数):self.属性1=参数 ——为对象指定值——python创建实例自动运行的方法
###### 注意:实例化:根据类建立对象|属性:可以通过实例访问的变量|属性参数与函数参数一样有很多变化方式
###### II.给属性指定默认值:直接初始化,不接受参数输入
###### III.类中所有方法想要调用属性参数——需要传入self参数
###### IV._参数(受保护属性)(其他类可以访问,外部可访问)  __参数(私有属性)(其他类一般不能访问)
###### 补充: 强制访问私有属性——名称改写:_ClassName__private_member
###### V.动态属性(动态为对象添加属性)——动态语言的特性
###### 范式:对象.属性=内容
###### 如果不希望动态添加属性,可以使用 \_\_slots\_\_魔法;范式: class 类名: \_\_slots\_\_=('属性1','属性2')
##### e.修改属性的值
###### I.范式1: 对象.属性=XXXX
###### II.范式2: 编写方法辅助更新属性(包括重置,更新)
##### f.方法的链式调用(前一个有返回值值)
#### 4.面向对象编程的三大特点
##### a.封装(encapsulation)
###### I.隐藏函数内部一切可以隐藏的实现细节,只向外部暴露简单的调用接口
###### II.只知道方法的名字和参数,隐藏方法的内部实现细节
##### b.继承(inheritance)——通过多重继承实现复杂层递的角色设计
###### I.实现类的特化和泛化
###### II.父类(超类,基类)——>子类(派生类,衍生类)
###### III.定义一个类时,未指定父类,默认认为时object类;允许多重继承
###### IV.继承范式: class 子类(父类):
###### V.调用父类初始化方法:范式:super().\_\_init\_\_(属性参数)-----在超类的基础上初始化;类的范式: class 类名(父类名):
###### VI.里氏替换原则(Liskov Substitution Principle)——子类可以继承父类的属性和方法,也有自己的属性和方法.开发时用子类对象去替换掉一个父类对
###### VII.方法重写:直接重写;子类方法将覆盖父类的方法
###### VIII.组合——将大类拆解为小类的组合---将小类的实例作为大类的属性;范式: self.属性名=小类()
##### c.多态(polymorphism)
###### I.基于对象类型的动态分派
###### II.继承相同的父类,对相同的方法进行不同程度的重写,完成不同的任务
#### 5.内置对象(已经存在的对象,只需要给对象发消息)
#### 6.类之间的关系:is-a关系(继承|泛化),has-a关系(关联),use-s关系(依赖)
#### 7. 类|模块的导入
##### 范式1: from 模块 import 类1(as 别名),类2...(继承时推荐)
##### 范式2: import 模块 as 别名
##### 范式3: from  模块 import *——不推荐:无法指出导入什么类,名称冲突

## 测试
### 0.pytest库
### 1.单元测试(函数的某个方面没有问题)——测试用例(一组测试用例)——全覆盖测试
### 2.测试文件(test_xxx):测试函数- def test_xxx(): 断言(声称满足特定条件)
### 3.测试类:在测试函数中测试
### 4.夹具:@pytest.fixture 函数——>可供多个测试使用的资源——> 消除重复
#### 注意: 大项目比较适合|形参和函数名相同|

## 编辑器——语法高亮

## python之禅:(import this)
### 基本原则: 可读,可行
#### +可读:注释(多一点注释,为函数,类,方法写明功能);名称(变量,函数等标识符处的命名合理)
#### 可行:最终能够解决实际问题,并且可以被他人使用(最初,可以从简洁的功能做起,最终实现整个功能)
### 进阶原则: 可读,简约
#### 可读: 名称尽量简洁能懂,注释简洁明白
#### 简约: 代码删繁就简,交互性更好,简洁,干净的输出

##  PEP8(Python Enhancement Proposal)
### 缩进:4个空格
### 行长:注释行长不超过72个字符,每行不超过80个字符
### 空行:使代码看起来整洁，不同功能区之间建议使用
### 条件测试:运算符附近空一格
### 函数:
#### 1. 描述性名称(小写字母和下划线)
#### 2. 阐释功能的注释
#### 3. 形参或者关键字参数的等号附近无空格
#### 4. 函数之间建议空两行
#### 5. 所有的import语句放开头
#### 6. 开头描述整个程序
### 类:
#### 1. 驼峰命名法:类名的每个单词的首字母大写，不使用下划线
#### 2. 对象和模块名全小写且单词之间使用下划线
#### 3. 每个类之后,都有文档字符串——描述类的功能
#### 4. 每个模块需要文档字符串
#### 5. 空行: 类的方法之间使用一个空行;模块的类之间使用两个空行
#### 6. 导入库: 先导入标准库,一个空行,再导入自己的模块
### 重构:代码能正常运行之后,将其划分为一系列的函数进行改进