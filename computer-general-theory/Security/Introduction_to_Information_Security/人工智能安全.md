# 人工智能安全

##  生词

> 1. 专家系统
> 2. ChatGPT
> 3. API
> 4. MP
> 5. ENIAC
> 6. LT逻辑理论机
> 7. LISP语言
> 8. 机器虫
> 9. 符号主义、连接主义、行为主义
> 10. ⾃然智能、⼈⼯智能、集成智能
> 11. 元宇宙

## 专家系统ES

> 专家系统是一种**早期形式的人工智能**，旨在模仿人类专家在特定领域内的决策能力。它通过将人类专家的知识编码为一组**规则和事实**，并使用推理引擎来处理这些规则，从而解决复杂的问题。

>  （通义）LLM不是专家系统

> 1. **知识库**：这是专家系统的核心部分，包含了大量关于特定领域的规则和事实。规则通常采用“如果...那么...”的形式（例如，“如果病人的体温超过38度，那么病人可能有发烧的症状”）。事实则是已知的条件或状态。
> 2. **推理引擎**：推理引擎负责应用知识库中的规则来进行推理。它根据用户提供的信息和当前的状态，选择合适的规则并执行相应的动作。推理过程可以是正向链（从已知的事实开始寻找适用的规则）或反向链（从问题出发，追溯需要的信息）。
> 3. **解释设施**：为了增加系统的透明度，专家系统通常包括一个解释设施，可以解释其决策过程，让用户了解为什么做出某个决定。
> 4. **用户界面**：提供一个人机交互的界面，使得非技术人员也能与专家系统交流，输入问题或数据，并获取解决方案或建议。

> 许多传统意义上的专家系统已经被更加灵活的机器学习方法所取代或增强，但在某些特定领域内，经典专家系统仍然发挥着重要作用。

## ChatGPT

ChatGPT，全名是“Chat Generative Pre-trained Transformer”，它是由OpenAI开发的一个大型语言模型。和传统专家系统不同，ChatGPT不是基于规则的系统，也不是为了解决特定领域的问题而设计的。

相反，ChatGPT是一个基于深度学习的模型，它通过在大量文本数据上进行训练来学习语言模式，并能够根据用户提供的提示生成连贯的文本响应。它可以用于对话、问答、文本创作等多种自然语言处理任务，并且它的应用范围非常广泛，不限于任何特定的专业领域。

## API

 "Application Programming Interface"（应用程序编程接口）的缩写

它是一组定义和协议，用于构建和集成软件应用程序。

API 允许不同的软件系统之间相互通信，提供了一种标准化的方法来请求服务或交换数据，而不需要了解底层实现细节。

> API和class的区别：
>
> 类是关于如何在程序内部组织代码和逻辑
>
> API是关于如何让不同的软件组件（可能是同一程序的不同部分，也可能是完全独立的应用程序）相互交流和协作。API确实提供了一种接口，但它不仅仅局限于类的范畴，而是涵盖了更广泛的软件交互方式

> API和DLL的区别：
>
> API更像是一个契约或规范，它描述了应该提供什么功能以及如何使用这些功能；而DLL则是一个具体的实现方式，它包含了实际的代码和数据。API并不直接等同于DLL，但它经常依赖于DLL来提供其承诺的功能。

> API和端口的区别： 
>
> - **抽象层次**：API是一个更高层次的概念，它描述了如何通过代码进行交互；而端口是一个较低层次的概念，它是网络通信的一部分，负责数据包的寻址和路由。
> - **目的**：API旨在提供一种方便的方式来访问某些功能或资源，而端口是为了在网络上传输数据时正确地定位到接收方的应用程序。
> - **使用场景**：当你想要集成第三方服务或与其他系统交换数据时，你会使用API；而当你配置服务器或诊断网络问题时，你可能会涉及到端口的设置和管理。
> - 在实际应用中它们常常一起工作

## MP(MCP)

**McCulloch-Pitts 模型**（通常简称为 MCP 模型）

麦卡洛克-皮茨

- **时间**：1943年
- **作者**：Warren McCulloch 和 Walter Pitts
- 特点：
  - **二进制输入和输出**：每个神经元接收二进制（0或1）输入，并产生二进制输出。
  - **加权和阈值机制**：神经元对所有输入信号进行加权求和，如果总和超过了预设的阈值，则神经元被激活并输出1；否则输出0。
  - **简单性**：MCP模型非常简化，忽略了实际生物神经元中的许多复杂特性，如非线性、时延等。
  - **逻辑运算能力**：尽管简单，MCP模型能够实现基本的逻辑运算，例如AND、OR、NOT等。

~~~python
class McCullochPittsNeuron:
    def __init__(self, weights, threshold):
        """
        初始化神经元的权重和阈值。
        
        :param weights: 权重列表，长度应与输入数量相匹配
        :param threshold: 阈值，用于确定神经元是否激活
        """
        self.weights = weights
        self.threshold = threshold

    def activate(self, inputs):
        """
        根据输入信号计算神经元的输出。
        
        :param inputs: 输入信号列表，每个元素为0或1
        :return: 输出信号，0或1
        """
        if len(inputs) != len(self.weights):
            raise ValueError("输入的数量必须与权重的数量相匹配")

        # 计算加权和
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs))
        
        # 判断是否超过阈值
        return 1 if weighted_sum >= self.threshold else 0


# 示例使用
if __name__ == "__main__":
    # 定义权重和阈值
    weights = [1, 1]  # 对于AND逻辑门，两个输入都为1时才激活
    threshold = 2     # 需要两个输入都为1才能超过阈值
    
    # 创建神经元实例
    neuron = McCullochPittsNeuron(weights, threshold)
    
    # 测试不同的输入组合
    test_inputs = [
        (0, 0),  # 应该输出0
        (0, 1),  # 应该输出0
        (1, 0),  # 应该输出0
        (1, 1)   # 应该输出1
    ]
    
    print("测试McCulloch-Pitts神经元 (模拟AND逻辑门):")
    for inputs in test_inputs:
        output = neuron.activate(inputs)
        print(f"输入: {inputs}, 输出: {output}")
        """
        权重：在这个例子中，我们设定了两个输入的权重都为1，这对应于一个简单的AND逻辑门。如果两个输入都是1，则加权和为2，超过阈值2，因此输出为1；否则输出为0。
阈值：设定为2，意味着只有当所有输入均为1时，加权和才会达到或超过阈值，从而触发激活状态。
激活函数：这是一个简单的阶跃函数，当加权和大于等于阈值时返回1，否则返回0。
        """ 
       
~~~

~~~c
#include <stdio.h>
#include <stdlib.h>

// 定义激活函数
int activate(int *inputs, int *weights, int num_inputs, int threshold) {
    int weighted_sum = 0;
    
    // 计算加权和
    for (int i = 0; i < num_inputs; ++i) {
        weighted_sum += inputs[i] * weights[i];
    }
    
    // 判断是否超过阈值
    return (weighted_sum >= threshold) ? 1 : 0;
}

int main() {
    // 定义权重和阈值
    int weights[] = {1, 1};  // 对于AND逻辑门，两个输入都为1时才激活
    int threshold = 2;       // 需要两个输入都为1才能超过阈值
    
    // 测试不同的输入组合
    int test_inputs[][2] = {
        {0, 0},  // 应该输出0
        {0, 1},  // 应该输出0
        {1, 0},  // 应该输出0
        {1, 1}   // 应该输出1
    };
    int num_tests = sizeof(test_inputs) / sizeof(test_inputs[0]);
    
    printf("测试McCulloch-Pitts神经元 (模拟AND逻辑门):\n");
    for (int i = 0; i < num_tests; ++i) {
        int output = activate(test_inputs[i], weights, 2, threshold);
        printf("输入: (%d, %d), 输出: %d\n", test_inputs[i][0], test_inputs[i][1], output);
    }

    return 0;
}
/*activate 函数：这是核心函数，它接收指向输入数组和权重数组的指针、输入的数量以及阈值作为参数。它计算加权和，并根据是否超过阈值返回1或0。
main 函数：在主函数中，我们定义了权重和阈值，并测试了几组输入组合。每组输入都被传递给 activate 函数以计算输出，并将结果打印出来。*/
~~~

## ENIAC

Electronic Numerical Integrator and Computer，电子数值积分计算机

世界上第一台通用型电子数字计算机

1945年2月14日在美国宾夕法尼亚大学正式启用，由约翰·普雷斯珀·埃克特（J. Presper Eckert）和约翰·莫奇利（John Mauchly）领导的团队设计并建造

并行处理架构，允许同时进行多个计算

## LT逻辑理论机

Logic Theorist，逻辑理论机

- **目的**：Logic Theorist的主要目标是证明数学定理，特别是来自怀特海和罗素的《数学原理》（Principia Mathematica）中的定理。该程序旨在模仿人类的推理过程，并探索机器是否可以进行创造性思维。
- **方法**：LT使用了一种基于规则的搜索算法来尝试从已知的前提推导出新的结论。它采用了**启发式搜索技术**，选择最有希望的路径进行探索，而不是盲目地尝试所有可能的组合。这使得LT能够在合理的时间内找到有效的证明。
- **成就**：Logic Theorist成功地证明了《数学原理》中的一些定理，包括著名的“Pons Asinorum”（驴桥定理），即等腰三角形底角相等的定理。虽然这些证明并不复杂，但在当时这是一个重要的突破，因为它展示了计算机可以通过符号操作来进行逻辑推理。
- **影响**：Logic Theorist对人工智能领域产生了深远的影响。它是第一个真正意义上的人工智能程序，为后续的研究奠定了基础。此外，它还促进了认知科学的发展，鼓励科学家们思考如何用计算机模型来理解人类思维的本质。
- **后续工作**：纽厄尔和西蒙基于Logic Theorist的经验，进一步开发了General Problem Solver (GPS)，这是一个更通用的问题解决框架。GPS试图将问题分解成子目标，并通过一系列步骤逐步解决问题。这一工作成为了早期AI研究的重要组成部分。



## LISP

LISP（LISt Processor，列表处理语言）是一种历史悠久的编程语言，首次出现于1958年，由约翰·麦卡锡（John McCarthy）及其同事在麻省理工学院开发。LISP 是最早的高级编程语言之一，并且对人工智能领域的发展产生了深远影响。它以强大的符号计算能力和灵活的数据结构而闻名。

### LISP 的特点

1. **列表和递归**：
   - LISP 最显著的特点是其对列表的支持。列表是最基本的数据结构，可以嵌套来表示复杂的数据结构。
   - 递归是 LISP 编程的核心技术，函数可以调用自身来解决问题。
2. **动态类型系统**：
   - LISP 拥有一个动态类型系统，在运行时确定变量的类型，而不是编译时。
3. **宏系统**：
   - LISP 提供了强大的宏系统，允许程序员编写代码生成代码，极大地扩展了语言的功能。
4. **解释性和编译性**：
   - LISP 可以被解释执行也可以被编译为机器码。早期版本主要是解释性的，但现代实现通常支持高效的编译。
5. **垃圾回收**：
   - LISP 是最早引入自动内存管理（即垃圾回收）的语言之一，这大大简化了内存管理的任务。
6. **函数式编程**：
   - LISP 是函数式编程的先驱，强调不可变数据结构和无副作用的纯函数。
7. **多态性和高阶函数**：
   - LISP 支持多态性和高阶函数，使得它可以处理抽象问题并创建通用算法。

### 主要方言

LISP 发展出了多个不同的方言，其中最著名的是：

- **Common Lisp**：一种标准化的LISP方言，广泛用于商业应用和个人项目。它拥有丰富的库和工具链。
- **Scheme**：另一种流行的LISP方言，以其简洁性和教学用途著称。Scheme 强调最小化核心特性，鼓励通过宏和其他机制进行扩展。
- **Clojure**：一个较新的LISP方言，运行在Java虚拟机上，结合了函数式编程和并发编程的优势。
- **Emacs Lisp**：用于GNU Emacs文本编辑器的扩展语言，虽然相对古老但仍非常活跃。

### 应用领域

由于其强大的符号处理能力，LISP 在以下领域特别有用：

- **人工智能和机器学习**：特别是在专家系统、自然语言处理等方面。
- **符号计算**：如数学软件包Mathematica就使用了一种LISP方言。
- **教育和研究**：许多计算机科学课程中教授LISP，因为它有助于理解编程语言的概念和原理。

### 示例代码

这里是一个简单的LISP程序，用于计算斐波那契数列的第n项：

lisp深色版本

```
(defun fibonacci (n)
  (if (or (= n 0) (= n 1))
      n
      (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))

; 调用函数
(fibonacci 10) ; 输出 55
```



