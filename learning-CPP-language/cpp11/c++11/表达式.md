> 表达式由运算对象组成,表达式一定有结果
> 复杂表达式拥有运算符
> 字面值和变量是最简单的表达式
### 运算符
> 函数调用也是运算符,运算对象的数量没有限制
#### 组合方式（依照结合律和优先级加括号）
1. 高优先级运算符的运算对象比低优先级运算符的运算对象更为紧密地组合在一起
2. 优先级相同,组合规律由结合律决定
>左结合律:从左向右的顺序组合运算对象
>右结合律:从右向左的顺序组合运算对象
3. 括号无视普通的优先级与结合律
#### 求值顺序
1. 大多数情况下,运算符没有规定求值顺序;
> << 运算符:没有规定何时以及如何求值
>同一表达式下，对象如果相关,但是运算符没有规定求值顺序，将产生未定义的行为
2. 4种明确规定求值顺序的运算符:&& ||(先求左侧运算对象的值)    ?: ,
#### 算术运算符
![[Pasted image 20250215121112.png]]
> 一元正号运算符作用于一个指针或算术值时，返回运算对象值的一个(提升后的)副本
> (C++11)商一律向0取整(直接切除小数部分)
> (C++11)取模运算符规定:结果符号和被除数相同
3. 运算对象:任意的算术类型和任意能转换为算术类型的类型;右值
4. 结果:右值
5. 表达式求值前，所有运算对象最终会转化成为同一类型
6. 算术表达式的未定义结果的情况:(1)数学性质;(2)计算机特点(溢出)
#### 逻辑和关系运算符
![[Pasted image 20250215122624.png]]
> && || 求值顺序:从左向右,存在短路求值的策略、
> 连续的几个关系运算符连在一起会产生意想不到的结果
1. 关系运算符运算对象: 算术类型或指针类型;右值;
2. 逻辑运算符运算对象:任意能转化为布尔值的类型;右值
3. 关系运算和逻辑运算符的返回值:布尔类型;右值
#### 赋值运算符
1. 运算对象: 左侧运算对象必须是可修改的左值
2. 运算结果: 左侧运算对象;左值;左侧运算对象类型
3. 结合律:右结合律
4. 优先级:较低
> 相较于关系运算符较低;
> 切勿混淆相等运算符和赋值运算符
5. 复合赋值运算符: ![[Pasted image 20250215124715.png]]
> 求值次数减少

#### 递增和递减运算符
1. 前置版本求值结果: 改变后的对象;左值
2. 后置版本求值结果: 改变前的值的副本;右值
3. 递增和递减运算对象:左值运算对象
4. 优先级: 高于解引用
> 常见的复合范式:*pointer++ 等价于\*(pointer++)

#### 成员访问运算符
> 包括点运算符和箭头运算符
> 点运算符获取类对象的一个成员
> 表达式:ptr->mem 等价于 （\*ptr）.mem

1. 优先级: 点运算符的优先级高于解引用运算符4
2. 运算结果: 箭头运算符作用于指针类型的运算对象结果是左值；点运算符的结果与成员所属的对象属性一致
#### 条件运算符
> cond?expr1:expr2

1. 运算结果:两个表达式都是左值或者能转化为同一种左值类型,结果为左值；否则，右值
2. 结合律:右结合律
3. 优先级:非常低
#### 位运算符
![[Pasted image 20250215133804.png]]
>符号位没有明确的处理规定
> \>\> : 在右侧插入值为0的二进制位
> << : 左侧运算对象的类型是无符号，在左侧插入值为0的二进制;类型是有符号,在右侧插入为符号位的副本或者为0的二进制位
> 出现整数提升
1. 运算对象:整数类型,并把运算对象看成是二进制位的集合
2. 结合律:移位操作符(IO运算符)满足左结合律
3. 优先级:移位操作符比算术运算符的优先级低,但比关系运算符,赋值,条件运算符的优先级高
#### sizeof运算符
> 返回值:size_t类型的常量表达式
> 形式:sizeof (type);sizeof expr
> (C++11)允许使用作用域运算符获取类成员的大小
> sizeof运算符不依赖于具体的对象，部分依赖于起作用的类型
> ![[Pasted image 20250215142119.png]]
> ![[Pasted image 20250215142127.png]]
> > 最后一点：只返回string.vector类的大小
1. 结合律: 右结合
2. 优先级:与\*的优先级一致
#### 逗号运算符

1. 结合律:左结合律
2. 求值结果:右侧运算对象
#### 运算符优先级表
![[Pasted image 20250215164218.png]]![[Pasted image 20250215164227.png]]
### 类型转换
#### 隐式转换
1. 大多数的表达式中,比int小的类型-->较大的整数类型
2. 条件中,非布尔值-->布尔类型
3. 初始化|赋值中,右侧运算对象转化为左侧的类型
4. 如果算术运算或关系运算对象由多种类型,需要转化为同一种类型;
5. 函数调用
##### 算术转换
1. 整数提升: 小整数类型--> 大整数类型
> bool ，char ,signed char ,unsigned char ,short ,unsigned short ---> int(只要所有值能存在int里)|unsigned int(否则)
> wchar_t, char16_t,char32_t -->int , unsigned int ,long ,unsigned long,long long ,unsigned long long 中最小的一种

2. 无,有符号类型的运算转化:(1)无符号不小于有符号,带符号的转化为无符号的(如果有符号是负数,那么产生副作用);(2)有符号数大于无符号数,依赖于机器(无符号类型的所有值能储存在该带符号类型中，转换;)
##### 其他隐式类型转换
1. 数组名转换为指针
> 例外，&数组名,sizeof 数组名,typeid 数组名
2. 指针的转化 
> (1). 0或nullptr能转化为任意指针类型
> (2).指向任意非常亮的指针能转化为void*
> (3).指向任意对象的指针能转化为const void*
> (4).
3. 转化为布尔类型
4. 转化为常量：可以增加底层const
5. 类类型动议的转换: 类类型能定义由编译器自动执行的转换,不过编译器每次只能执行一种类类型的转换
#### 显示转换
> 强制类型转换-->本质上是危险的
##### 命名的强制类型转换: cast-name<\type>(expression)
1. static_cast(条件:明确定义的类型转换,只要不包含底层const)
2. const_cast(只能改变运算对象底层的const,无法改变类型)---函数重载
3. reinterpret_cast(通常为运算对象的位模式提供较低层次上的重新解释)--依赖于机器且十分危险
4. dynamic_cast(支持运行时类型识别)
##### 旧式的强制类型转换:函数形式:type (expr);C语言风格:(type) expr;

### 重载运算符
> 运算符定义: 运算对象的类型和返回值的类型
> 不变的: 运算对象的个数,运算符的优先级,结合律

### 表达式的属性
#### 左值
##### 求值结果: 一个对象或者一个函数
> 解释: 
> 1. 常量对象等某些左值实际上不能作为赋值表达式的左侧运算对象
> 2. 某些表达式的左值是对象，但他们是右值

##### (使用左值)操作符
5. 赋值操作符:使用(非常量)左值作为左侧操作运算符,结果是左值
6. 取地址符:作用于左值运算对象,结果是(右值)指针
7. 解引用操作符,下标运算符,迭代器解引用运算符,string和vector下标运算符:结果是左值
8. 内置类型和迭代器的递增递减运算符:作用于左值运算对象
#### 归纳:
9. 左值可以位于赋值语句的左侧；右值可以位于赋值语句的右侧
10. 当一个对象被用作右值的时候,用的是对象的值(内容);当一个对象被用作左值的时候，用的是对象的身份(在内存中的位置)
> 在需要右值的时候可以使用左值代替,但是不能把右值当成左值使用(位置)，此时的左值实际上使用的是内容
11. dectltype:如果表达式的结果是左值,dectltype作于该表达式(不是变量)得到一个引用类型
### 建议
1. 拿不准的时候最好使用括号强制表达式的组合关系
2. 如果改变了某个运算对象的值，则在表达式的其他地方不要再使用这个运算对象(当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时无效)
3. 进行比较运算时，除非对象是布尔类型，否则不要使用布尔字面值作为运算对象
4. 条件语句中,赋值运算符部分加上括号 
5. 除非必须,否则使用前置版本的递增和递减运算符
6. 简洁可以成为一种美德
7. 在长表达式中，使用条件运算子表达式时，通常需要在它两端加上括号
8. 将位运算仅用于处理无符号类型
9. 避免强制类型转换

