### 引用(左值引用;引用将它和它的初始值对象绑定在一起)

#### 范式:Type &变量名=xxx;(声明必须初始化)

> 引用并非对象,只是为一个已经存在的对象所起的别名,且无法定义引用的引用

> 引用只能绑定一次且必须初始化

> 引用的类型要和与之绑定的对象严格匹配

> 除了两个例外,引用只能绑定在对象上,而不能与字面值或某个表达式的计算结果绑定在一起

#### 常量引用(对const的引用)

##### 范式:const type &标识符 = 任意变量|字面值常量

> 非const的引用 无法引用 const类型的变量

> const的引用时允许用任意表达式作为初始值,只要该表达式的结果能转化成引用的类型(临时量机制)

> 非const的引用 是对变量的直接引用;const的引用的是临时量

### 指针

#### 定义范式:Type *变量;

#### 初始化范式:Type *变量 = & 变量;

> 不能定义指向引用的指针

> 除了两个例外,指针的类型都要和它所指向的对象严格匹配

#### 指针值:指向一个对象;指向紧邻对象所占空间的下一个空间;空指针,意味着指针没有指向任何对象;无效指针(野指针)

#### 解引用范式:*指针(解引用)

> 解引用操作适用于指向某个对象的有效对象

#### 空指针:nullptr(C++11);0;NULL(预处理变量;cstdlib)

> 不能将值为0的变量赋给指针

#### 常见指针操作:1. 指针;2. 逻辑判断(指针合法性判断;指针相等);

> 指针相等的情况:1. 空指针;2. 指向同一个对象;3. 指向了同一个对象的下一个地址;4. 有时,一个指针指向一个对象,另一个指向另外对象的下一个地址

#### void*指针(存放任意对象的地址;但不清楚时什么类型的对象)

##### 操作: 1. 比较;2. 函数的输入输出;3. 赋给另一个void*指针;

> 不能对void\*解引用,不能直接操作void\*指针所指的对象

#### 指向指针的指针(二级指针..): **(*..)标识符

#### 指向指针的引用: Type *&r=标识符;

> 不存在指向引用的指针

> 从右向左阅读,离变量名最近的符号对变量的类型由最直接的影响

#### 指向常量的指针

##### 范式:const Type *标识符 = &任意变量

> const 修饰的变量只能由const修饰的指针指向

> const 修饰的指针可以指向任意非const修饰的变量,无法通过指针修改值,但是可以通过其他方式

##### const指针

###### 范式:Type * const 标识符 = &任意变量

###### 范式:const Type * const 标识符 = &任意常量;constexpr const Type * 标识符=&任何变量(指向常量的常量指针)

##### 顶层const和底层const

###### 顶层const:指针本身是个常量;

###### 底层const:指针所指向的对象是个常量;

> 容易混淆的是 const+非指针类型 和 const+指针类型

#### 指针运算(迭代器运算)

### 数组

> 数组也是存放相同类型对象的容器

> 相较于容器,性能较好,灵活性下降

> 数组不允许拷贝和赋值

#### 定义

##### a.默认初始化

###### 范式:Type 数组名[\维度];

> 维度必须是常量表达式

> 必须指定数组的类型,不允许使用auto关键字

> 数组的元素应是对象,而不是引用

##### b.列表初始化

###### 范式:Type 数组名[] = {a,b,c...};

> 此时允许省略维度

##### c.字符数组的特殊性

###### 范式:char 数组名[] = "字符串字面值";

> 注意: 字符串字面值的尾部有一个'\0'

#### 访问

##### a.下标范式: 数组名[\索引];

> 下标的类型是size_t类型,机器相关的无符号类型(能够表示内存中任意对象的大小);使用头文件<\cstddef>

##### b.范围for语句:for(auto &变量: 数组名);

##### c.迭代器(指针语法)

#### 指针和数组

> 很多用到数组名字的地方,编译器使用指向数组首元素的指针来代替

> 使用数组的的时候,编译器一般会把它转会为指针

##### auto 关键字识别数组名为指针

##### decltype(数组)为数组类型

##### 标准库函数begin(数组名)和end(数组名);

> 返回值获得头指针和尾指针

> 尾后指针不能解引用和递增操作

##### 数组名运算

> 数组名+整数:自动将数组名转化为指针

> 指针-指针:返回值是ptrdiff_t类型(带符号整形数)(定义在头文件中</cstddef>)

> 数组下标运算<===>指针运算+解引用运算

#### 多维数组(数组的数组)

##### a.定义初始化

###### 范式:Type 数组名[\维度1][\维度2]...;

###### 范式:Type 数组名[\维度1][\维度2]... = {{a,b,c...},{d,e,f...}...};(列表初始化)

> 内层也可以没有花括号;有花括号的时候,内层元素不足时,会自动补0

##### b.访问

###### I.下标范式: 数组名[\维度1][\维度2]...;

> 根据维数,得到数组名或者元素

###### II.范围for语句:for(auto &变量: 数组名);

> 非最内层变量声明称引用,避免auto识别成指针

##### c.指针和多维数组

###### 多维数组名实质上是指向数组的指针

> auto 和 decltype 识别数组类型

##### d.类型别名

###### 范式:using 类型别名 = 类型;

###### 范式:typedef 类型 类型别名;

> 范式2有点反直觉

### C风格字符串

> 不推荐使用,容易引发错误

#### 操作

> 需要使用<\cstring>头文件

> ![alt text](image-9.png)

> 不负责验证其字符串的参数

### 编写建议

#### 1.检查下标是否越界

#### 2.推荐使用string标准库,不建议使用C语言风格字符串