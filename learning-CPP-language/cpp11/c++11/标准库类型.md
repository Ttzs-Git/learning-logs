
### string

> 可变长的字符序列。严格讲,string不是容器

> 使用必须包含头文件<\string>

#### 类型

##### string 类型

> **字符串字面值不是string对象,类型不同**

##### string::size_type 类型

> size_type是一个无符号类型,用于存放任何string对象的大小

> 要注意无符号整形和整形负数的比较,负数会自动转化成无符号整形

#### 初始化范式

##### 1.string 声明符列表;(默认初始化;空字符串)

##### 2.string 声明符 = 另一个声明符;(拷贝初始化)

##### 3.string 声明符 = "内容";(直接初始化)

##### 4.string 声明符列表(内容|另一个声明符);

##### 5.string 声明符(n,'字符');(n个字符重复形成的字符串)

##### 6.string 声明符 = string(n,'字符');(不推荐)

#### 操作(函数名调用,重载运算符)

##### 1.读写操作

###### I.读入操作:is>>string;getline(is,string);

###### 常用操作:cin>>string;getline(cin,string);

> 读入操作会忽略空白字符(空格,换行符,制表符),直到下次空白字符出现

> getline()函数保留空白符,直到换行符(换行符也被读进来),然后将内容存到string对象中(不存换行符)，返回流参数;换行符只是标志,并不会被拷贝

###### II.写出操作:os<<\string<<\endl;

###### 常用操作:cout<<\string<<\endl;

##### 2.empty()和size()操作

###### I.string.enpty():判断字符串是否为空

###### II.string.size():返回字符串的长度;返回值类型是string::size_type

##### 3.比较操作(==,!=,>,<,>=,<=)

> 比较原则:字典顺序(长度和每个字符的ASCII)

##### 4.赋值操作(=)

##### 5.连接操作(+,+=)

> 字符字面值和字符串字面值都可以通过**赋值或者连接操作**准化成string对象

> string对象和字符字面值及字符串字面值的连接操作,必须保证**运算符两侧至少一个**是string对象。

> 由于运算从左向右进行,因此允许"s+" "+ " "...."

##### 6.范围语句(C++11)

###### I.范围for语句:for(声明符:表达式)

> for(auto 变量: string)

> for(auto &变量: string)--->引用;可以修改字符

##### 7.访问

###### I.下标范式: string[\索引]

> 输入参数是string::size_type类型

> 如果是带符号的值,会自动转化成无符号整形,索引值必须非负

> 越界访问和访问空串的行为是未定义的

> 附:对于字符的函数(使用<\cctype>)![alt text](image-8.png)

###### II.迭代器范式;

##### 8.调整字符串

###### 调整范式:string.resize(n,'char')

> n：size_type类型;char:字符

> 如果string的长度小于n,则在string的末尾添加n-string.size()个默认字符('char'或者'\0');如果string的长度大于n,则删除string.size()-n个字符

#### string和C风格字符串

##### a.字符串字面值初始化string对象

##### b.允许以空字符结束的字符数组初始化|赋值string对象

##### c.允许C风格字符串作为加法运算的一个运算对象

##### d.允许C风格字符串作为string对象的复合赋值运算的右侧运算对象

> 简答而言,允许C风格字符串转化为string对象，但反之,不允许

##### e.string.c_str()函数-->返回值是C语言风格字符串(一个指针)

> 指针类型是const char*

> 后续操作如果改变了string，可能导致返回值失效,建议拷贝返回值

### vector模板(向量)

> 相同类型的对象的集合,因此不存在包含引用的vector

> 使用必须包含头文件<\vector>

> vector是一个类模板,某个类型的容器

> 模板:为编译器生成类或函数编写的一份说明

> 实例化:编译器根据模板创建类或函数的过程

> vector<\vector<\类型>>(c++11)

> 可以动态地增长

#### 1.定义和初始化

##### a.默认初始化

###### 范式:vector<\类型> 标识符;(空vector)

##### b.拷贝初始化

###### 范式:vector<\类型> 标识符(另一个vector);

###### 范式:vector<\类型> 标识符=另一个vector;

> 拷贝初始化的类型要一致

##### c.列表初始化

###### 范式:vector<\类型> 标识符{a,b,c...};

###### 范式:vector<\类型> 标识符={a,b,c...};

> 初始化多元素只能采用列表初始化

##### d.构造对象

###### 范式:vector<\类型> 标识符(n,值);(n个重复的值)(构造对象)

###### 范式:vector<\类型> 标识符(n);(n个默认初始化的值;值默认初始化)(构造对象)

> 限制:有些值要求必须明确地提供初始值;

> 不能使用字符串字面值构造vector<\stirng>

###### 范式:vector<\类型> 标识符={n,值};(n个重复的值)(类型不能和n一致)

##### e.数组转化

###### a.数组初始化vector对象:vector<\type> v(begin(数组),end(数组));

###### b.数组初始化vector对象:vector<\type> v(数组+a,数组+b);

> vector转化为数组,只能一个个赋值

#### 2.操作

##### a.添加元素

###### 范式:vector.push_back(值);

> 要求:确保所写的循环正确无误,特别是有可能改变vector对象的容量时候

> 范围for语句体内不应改变其所遍历序列的大小

##### b.empty()和size()

###### I.范式:vector.empty();(判断是否为空)

###### II.范式:vector.size();(返回vector的大小)

> 返回值是:vector<\类型>::size_type

##### c.访问元素

###### I.范式:vector[\索引];

> 不能像python一样通过索引添加元素;仅能通过索引访问已经存在的元素

> []是标准库定义的,索引值必须非负

###### II.范式:for(auto &变量: vector);(引用;可修改)

###### III.范式:for(auto 变量: vector);(不可修改;只读)

###### IV.使用迭代器范式

##### d.拷贝替换

###### 范式:vector=另一个vector;

###### 范式:vector={a,b,c...};

##### e.逻辑判断(==,!=,>,<,>=,<=)(比较的前提是同类型;字典顺序比较)

#### 两个限制

##### 1. 不能在范围for语句中添加元素(遍历vector时不要添加)

##### 2. 任何一种可能改变vector对象的容量的操作都可能使指向vector对象的迭代器失效

### 迭代器(指向容器中的元素)

> 所有的容器和string都支持迭代器

> 迭代器有有效和无效之分

#### 类型:

##### 迭代器类型:vector<\类型>::iterator

> iterator:迭代器类型

##### const迭代器类型:vector<\类型>::const_iterator

> const_iterator:常量迭代器类型,只能进行读取操作

#### 成员函数:

##### 容器.begin()(指向第一个元素)

##### 容器.end()(尾后迭代器;指向容器最后一个元素的下一个位置)

##### 容器.cbegin()(指向第一个元素)

##### 容器.cend()(尾后迭代器;指向容器最后一个元素的下一个位置)

> cbegin()和cend():cbegin()返回的是const_iterator类型的迭代器

> 空容器<===>容器.begin()==容器.end()

#### 运算符:

##### 1.解引用运算符(*)范式: *iter;

##### 2.箭头运算符(->)范式: iter->成员函数;(*item.成员函数)

##### 3.递增运算符(++)范式: ++iter;(下一个元素)

##### 4.递减运算符(--)范式: --iter;

##### 5.逻辑运算符(==,!=)范式(同一个元素则是相等)

#### string和vector支持的运算

###### iter + n:返回迭代器向前移动n个位置的迭代器

###### iter - n:返回迭代器向后移动n个位置的迭代器

###### >,>=,<,<=:比较两个迭代器的位置关系

###### iter1 - iter2:返回两个迭代器之间的距离

> 返回值类型:vector<\类型>::difference_type(带符号整形数)

###### 复合运算符:+= -=

### 编写建议

#### 1. 访问序列前,检查字符串是否为空或者索引是否越界

> 推荐使用,string::size_type类型的索引,因此只需要检查是否小于size()

> 尽可能使用范围for语句

#### 2. for语句推荐使用!=和迭代器而不是<,因为!=适用于所有迭代器类型

#### 3.不要向已经使用迭代器的容器中添加元素

#### 4.尽量避免使用内置数组和指针,多使用vector和迭代器

#### 5.尽量使用string,避免使用C风格字符串