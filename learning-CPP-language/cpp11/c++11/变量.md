(一块能储存数据并具有某种类型的内存空间)

### 声明(规定:变量的类型和名字;分离式编译机制)

#### 范式1: 基础数据类型 变量名列表;

#### 范式2: extern 基础数据类型 变量名列表;(拓展定义域)

> 在函数体内部,如果试图将初始化一个由exteren 关键字标记的变量,将引发错误

#### 复合类型声明的范式3: 基础数据类型 声明符列表(声明符命名一个变量和与基础数据类型有关的某种类型)

> 类型修饰符时声明符的一部分

### 定义:

#### 1. 范式: 基本数据类型 \[类型说明符\ 标识符\](变量名以逗号分隔,分号结束)

#### 2. 标识符的规则:

##### I.下划线,字母,数字(前两者可以作为开头);

##### II. 关键字和操作符替代名无法作为标识符;

##### III. 不能出现连续两个下划线,不能以下划线紧连接大写字母开头

##### IV. 定义在函数体外的标识符不能以下划线开头

##### V.其他规范: 体现实际意义;变量名全部小写;用户自定义类名大写字母开头;多个单词间要有明显区分,使用\'\_\'

#### 3. 作用域(解决相同名字的变量发挥作用的问题)

##### O.作用域大多数作用域以花括号分隔;

##### I.全局作用域:定义于所有函数体之外的名字

##### II.块作用域

##### III.嵌套作用域:外层作用域 && 内层作用域

> 内层可以访问外部定义的,内层可以重新定义外层已有的名字----与C语言一样

#### 4. const限定符

##### I.范式: const Type 声明符=内容;

##### II.操作:初始化

> const 和 非const类型的操作的区别是: const对象上执行不改变其内容的操作

##### III.文件和const: 默认状态时,const 对象仅在文件内有效;多文件共享,定义和声明前都将上extern

##### IV.顶层const和底层const

###### 顶层const:表示实体本身是常量

###### 底层const:表示指针或引用所指向的数据是常量，不能通过该指针或引用来修改这些数据。

###### 拷贝操作:顶层const不受影响;底层const的限制不能忽视,拷贝对象双方必须拥有相同的底层const资格(或者两个对象的数据类型必须能够转换)

> 类型转换:非常量转化为常量

##### V.常量表达式(常量表达式:值不会改变并且在编译过程中就能得到计算结果的表达式)

###### 字面值;用常量表达式初始化的const对象

##### VI.constexpr类型(C++11)

###### 声明范式:constexpr type 标识符;

###### 定义范式:constexpr type 标识符=xxx;

> 将变量声明constexpr类型,便由编译器来验证变量的值是否是一个常量表达式;

##### VII.字面值类型

> 算术类型,引用和指针都属于字面值类型;其中指针必须是nullptr或0,或者存储于某个固定地址中的对象

> > constexpr指针只能指向所有函数体之外的对象(地址固定不变)和staic修饰的变量

> > constexpr声明中如果定义了一个指针,限定符仅对指针有效,和指向的对象无关

> 自定义类,IO库,string等不属于字面值类型

### 初始化:(使用"字面值常量,变量,函数"进行对变量的初始化)

#### 1. 直接初始化

##### 范式1:基础数据类型 变量 = x

##### 范式2:基础数据类型 变量(x)

#### 2. 列表初始化(x为字面值常量)

##### 范式1:基础数据类型 变量 = {x}

##### 范式2:基础数据类型 变量{x}

> 当列表初始化并且初始值存在丢失风险(类型转换的时候),编译器将会报错---保障数据的有效性

##### 列表初始化的独特

###### 1.拷贝初始化时只提供一个初始值;

###### 2.提供类内初始值时,只能使用拷贝初始化或使用花括号形式的列表初始化;

###### 3.提供的是初始元素值的列表,则只能使用列表初始化,而不能放在花括号中

#### 3. 默认初始化(影响因素:变量的位置和变量的类型)

##### 定义于函数之外的变量(全局变量)被初始化为0

##### 定义于函数体内部的变量的内置类型(局部变量;块变量)将不被初始化,其值未定义

##### 每个类各自决定其初始化对象的方式,是否不经初始化就定义对象也由类自己决定(可以调节)

##### 绝大多数类如果没有显性的初始化,其值由类确定(参数的默认值)

#### 编写建议

##### 1. 建议初始化每一个内置类型的变量

##### 2. 使用变量之前必须声明其类型(编译器将会负责类型检查)

##### 3. 坚持标识符的命名规范

##### 4. 在第一次使用变量时,定义它(便于寻找和初始化)

##### 5. 如果函数有可能使用某全局变量,则不宜再定义一个同名的局部变量

##### 6. 尽量定义时初始化所有指针;定义对象之后再定义指向它的指针;或者初始化为nullptr或0

##### 7. 选择修饰符和变量标识符和空格的一种关系,我选择修饰符紧跟变量标识符

##### 8. 如果认定一个常量表达式,就把它声明为constexpr

##### 9. 阅读变量的声明或者定义时,从内向外,从右向左阅读