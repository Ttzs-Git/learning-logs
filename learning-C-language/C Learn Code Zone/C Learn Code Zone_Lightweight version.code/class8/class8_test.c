#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//使用调试技巧
//bug——>缺陷|计算机程序设计
//调试——找bug
//一名优秀的程序员是一名出色的侦探
//拒绝迷信式的调试

//调试—Debug——除错；发现和减少计算机程序或电子仪器设备中程序错误的过程
//基本过程:发现程序错误——>程序员自己，测试人员（需求文档+测试用例），用户（——>可能赔偿）
//以隔离、消除等方式对错误进行定位（测试人员——>报bug）
//确定错误产生的原因
//提出纠正错误的解决方法
//对程序错误予以改正，重新测试

//debug—调试版本:包含调试信息，不做任何优化,利于进行调试
//release—发布版本，往往进行了各种优化，使得程序在代码大小和运行速度上都是最优的，便于用户使用|不能调试
//int main()
//{
//	int i = 0;
//	int arr[10];
//	//赋值
//	for (i = 0; i < 10; i++)
//	{
//		arr[i] = i;
//	}
//	//打印
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d  ", arr[i]);
//	}
//	return 0;
//}
//环境准备——>debug
// 必须清晰程序应该是怎样的
// 快键键
//F5——>启动调试，经常用来直接跳到逻辑上的下一个断点处
//F9——>创建与取消断点；断电：放在有意义的代码处
// scanf无法跳过，只能互动；
//F10——>逐过程，一个过程可以是一次函数的使用；或者一条语句的使用
//F11——>逐语句，每次都执行一条语句；但是这个快捷键可以使我们的执行逻辑进入函数内部
// 函数调用上有区别:F11进入内部逐步进行；2013后调试不会在进入库函数了
//Ctrl+F5：开始执行不调试——生成可执行文件+调试
//静默断点
//
//条件断点的设置
//
//int add(int x, int y)
//{
//	return (x + y);
//}
//int main()
//{
//	int a = 19, b = 10;
//	add(a, b);
//	return 0;
//}
//Fn—辅助功能键
//F1——help
//F2——改名
//FN+F1=原来的F1
//要么Fn+F1|关掉Fn

//调试起来之后才有，窗口，进行打断点调试、监视、自动窗口、局部变量
//自动窗口：自动加入
//局部变量：自动加入
//但是会自动自动跳转
//监视；合法即可见|监视1与2.3.4
//对于相同标识符的东西，如何监视
//void test2()
//{
//	printf("heheh");
//}
//void test1()
//{
//	test2();
//}
//
//void test(int a[])//穿的是首元素的地址，所以只能看到一个元素的值和址//输入a,4——连续的4个数据|起始地址
//{
//	test1();
//}
//int main()
//{
//	int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
//	test(arr);
//	return 0;
//}
//查看内存的大小
//4表示设置一行显示4列；1列显示1个字节的数据
//4个字节代表一个整形的
//内存里真实存放的（以二进制储存）、以16进制显示数据
//地址（第一个字节的地址）+16进制+大概分析的数据（字符可以看懂，基本没啥用）

//调用堆栈
//代码的互相调用的关系
//栈就是压栈：在栈顶上放元素；出栈：出元素

//查看汇编信息
//在不同硬件上，汇编代码也不同

//查看寄存器的信息
//一个是寄存器；另一个是监视
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = a + b;
//	printf("%d\n",c);
//	return 0;
//}



//求n！的和
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int i = 0;
//	int sum = 0,item=1;
//	for (i = 1; i <= n; i++)
//	{
//		item *= i;
//		sum += item;
//	}
//	printf("%d\n", item);
//	printf("%d", sum);
//	return 0;
//}
//delete——快速删除监视
//调试——>把代码跟算法统一
//
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9 };
//	int i = 0;
//	//初步：越界访问
//	for (i = 0; i <=12; i++)//我的是在arr[15]
//	{
//		arr[i] = 0;//arr[10]越界访问
//		printf("heheh\n");
//	}
//	//更改arr[12]=12——>arr[12]=0   |&i==&arr[12];
//	return 0;
//}//最终出错的原因是越界访问
//但是在我的代码里面没有实现arr[12]=i;
//死循环的原理:
//i\arr局部数据，放在栈区
//栈区内存使用条件：
// 1、栈区内存的使用习惯总是先使用高地址处的空间，再使用低地址处的空间；
//2.数组随着下标的增长，地址由低到高变化
//可能性就此出现
//如果i和arr之间有适当的空间，利用数组的越界操作就可能会覆盖到i，就可能会导致死循环的出现的
//不同的编译其之间的空间是不一样的

//《C陷阱和缺陷》的书中提到

//视频中程序没有报错的原因：死循环；错误并不是总被报
//当i在arr之下创建，就不会那样；但是越界是原罪

//nice公司的笔试题

//如何写好调试的题目——优秀的代码
//代码运行正常|bug少|效率高|可读性高|可维护性高|注释清晰|文档齐全
#include<stdio.h>
//代码技巧
//使用assert |尽量使用const|养成良好的代码风格|添加必要的注释|避免编码的陷阱|

//模拟实现库函数使用strcpy()
#include<string.h>
int main()
{
    char arr1[20]={0};
    char arr2[]="hello bit";
    //char *strcpy(char *dest,const char *src);
    //            目标空间         源数据
    strcpy(arr1,arr2);
    printf("%s",arr1);
    return 0;
}
