#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//使用调试技巧
//bug——>缺陷|计算机程序设计
//调试——找bug
//一名优秀的程序员是一名出色的侦探
//拒绝迷信式的调试

//调试—Debug——除错；发现和减少计算机程序或电子仪器设备中程序错误的过程
//基本过程:发现程序错误——>程序员自己，测试人员（需求文档+测试用例），用户（——>可能赔偿）
//以隔离、消除等方式对错误进行定位（测试人员——>报bug）
//确定错误产生的原因
//提出纠正错误的解决方法
//对程序错误予以改正，重新测试

//debug—调试版本:包含调试信息，不做任何优化,利于进行调试
//release—发布版本，往往进行了各种优化，使得程序在代码大小和运行速度上都是最优的，便于用户使用|不能调试
//int main()
//{
//	int i = 0;
//	int arr[10];
//	//赋值
//	for (i = 0; i < 10; i++)
//	{
//		arr[i] = i;
//	}
//	//打印
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d  ", arr[i]);
//	}
//	return 0;
//}
//环境准备——>debug
// 必须清晰程序应该是怎样的
// 快键键
//F5——>启动调试，经常用来直接跳到逻辑上的下一个断点处
//F9——>创建与取消断点；断电：放在有意义的代码处
// scanf无法跳过，只能互动；
//F10——>逐过程，一个过程可以是一次函数的使用；或者一条语句的使用
//F11——>逐语句，每次都执行一条语句；但是这个快捷键可以使我们的执行逻辑进入函数内部
// 函数调用上有区别:F11进入内部逐步进行；2013后调试不会在进入库函数了
//Ctrl+F5：开始执行不调试——生成可执行文件+调试
//静默断点
//
//条件断点的设置
//
//int add(int x, int y)
//{
//	return (x + y);
//}
//int main()
//{
//	int a = 19, b = 10;
//	add(a, b);
//	return 0;
//}
//Fn—辅助功能键
//F1——help
//F2——改名
//FN+F1=原来的F1
//要么Fn+F1|关掉Fn

//调试起来之后才有，窗口，进行打断点调试、监视、自动窗口、局部变量
//自动窗口：自动加入
//局部变量：自动加入
//但是会自动自动跳转
//监视；合法即可见|监视1与2.3.4
//对于相同标识符的东西，如何监视
//void test2()
//{
//	printf("heheh");
//}
//void test1()
//{
//	test2();
//}
//
//void test(int a[])//穿的是首元素的地址，所以只能看到一个元素的值和址//输入a,4——连续的4个数据|起始地址
//{
//	test1();
//}
//int main()
//{
//	int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
//	test(arr);
//	return 0;
//}
//查看内存的大小
//4表示设置一行显示4列；1列显示1个字节的数据
//4个字节代表一个整形的
//内存里真实存放的（以二进制储存）、以16进制显示数据
//地址（第一个字节的地址）+16进制+大概分析的数据（字符可以看懂，基本没啥用）

//调用堆栈
//代码的互相调用的关系
//栈就是压栈：在栈顶上放元素；出栈：出元素

//查看汇编信息
//在不同硬件上，汇编代码也不同

//查看寄存器的信息
//一个是寄存器；另一个是监视
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = a + b;
//	printf("%d\n",c);
//	return 0;
//}



//求n！的和
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int i = 0;
//	int sum = 0,item=1;
//	for (i = 1; i <= n; i++)
//	{
//		item *= i;
//		sum += item;
//	}
//	printf("%d\n", item);
//	printf("%d", sum);
//	return 0;
//}
//delete——快速删除监视
//调试——>把代码跟算法统一
//
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9 };
//	int i = 0;
//	//初步：越界访问
//	for (i = 0; i <=12; i++)//我的是在arr[15]
//	{
//		arr[i] = 0;//arr[10]越界访问
//		printf("heheh\n");
//	}
//	//更改arr[12]=12——>arr[12]=0   |&i==&arr[12];
//	return 0;
//}//最终出错的原因是越界访问
//但是在我的代码里面没有实现arr[12]=i;
//死循环的原理:
//i\arr局部数据，放在栈区
//栈区内存使用条件：
// 1、栈区内存的使用习惯总是先使用高地址处的空间，再使用低地址处的空间；
//2.数组随着下标的增长，地址由低到高变化
//可能性就此出现
//如果i和arr之间有适当的空间，利用数组的越界操作就可能会覆盖到i，就可能会导致死循环的出现的
//不同的编译其之间的空间是不一样的

//《C陷阱和缺陷》的书中提到

//视频中程序没有报错的原因：死循环；错误并不是总被报
//当i在arr之下创建，就不会那样；但是越界是原罪

//nice公司的笔试题

//如何写好调试的题目——优秀的代码
//代码运行正常|bug少|效率高|可读性高|可维护性高|注释清晰|文档齐全
#include<stdio.h>
//代码技巧
//使用assert ——进行报错|尽量使用const——保护数据|养成良好的代码风格|添加必要的注释|避免编码的陷阱|

//模拟实现库函数使用strcpy()
#include<string.h>
#include<assert.h>
//void my_strcpy(char* str1, const char* str2)//长对象无法修改，扼杀错误在编译阶段
//{
//	/*do
//	{
//		*str1 = *str2;
//		str1++;
//	} while (*str1 != '\0');
//*/
////while (*str1 != '\0')
////{
////	*str1 = *str2;
////	str1++;
////	str2++;
////	//*str1++ = *str2++;
////}
//	//判断是是不是NULL
//	//断言
//	assert(str1 != NULL);
//	assert(str2 != NULL);//报错_保护程序员
//	while (*str1++ = *str2++)//当“\0”为假
//	{
//		;
//	}
//}
//char* my_strcpy(char* str1, const char* str2)//作为链式访问的，返回值是str1
//{
//	char* ret = str1;//返回值是str1
//	//判断是是不是NULL
//	assert(str1 != NULL);//报错误
//	assert(str2 != NULL);
//	while (*str1++ = *str2++);
//	return ret;
//}
//int main()
//{
//	char arr1[20] = "XXXXXXXXXXX";
//	char arr2[] = "hello bit";
//	char* p = NULL;
//	//char *strcpy(char *dest,const char *src);
//	//            目标空间         源数据
//	//STRCPY()函数的功能是把源数据复制到目标空间，并且返回目标空间的首地址
//	//strcpy（）会将字符串中的“\0”拷进去
//
//	printf("%s", my_strcpy(arr1, arr2));//%s只要有起始地址，就会打印出字符串
//	return 0;
//}

//int main()
//{
//	const int num = 0;
//	//num = 20;//长对象不能修改
//	 int* p = &num;
//	//*p = 40;//越过const的相关的作用
//	//const修饰指针变量
//	//1. const放在*左边
//	//const int* p;跟 int const*  p;效果相同//限制了p的指向，但是p指向的对象可以修改；const修饰*p
//	//cosnt 修饰的是* p无法修改，p指向的对象不能通过p来改变，但是p变量本身的值可以修改
//	// const int* p;
//	//p = &n;
//	 //2.const 放在*的右边
//	 int* const p = &num;
//	 *p = 10;//这是通过的
//	 int num =100;
//	 p = &num;
//	 //当p指向的对象改变时，p变量的值不能改变；变值，不变地址；
//
//	 //const int* const p=&num;//const修饰指针变量，指针变量的值不能改变，指针所指向的对象也不能改变
//	//*p = 20;//报错
//	//num = 30;//报错
//	//p = &num;//报错
//	//const int* p;//const修饰指针变量，指针变量的值可以改变，指针所指向的对象不能改变
//	//p = &num;//可以
//	//*p = 20;//报错
//	//num = 30;//可以
//
//	 //const 的作用，保护原数据
//
//
//
//
//	printf("%d", num);
//	return 0;
//}

//《高质量的C/C++编程》
//
////模拟实现strlen函数——字符串长度
//int my_strlen(const char* p)//保护数据不能被修改，提高代码的健壮性
//{
//	int count = 0;
//	assert(p);//在release 版本下被优化了
//	while (*p != '\0')
//	{
//		count++;
//		p++;
//	}
//	return count;
//}
//
//
//int main()
//{
//	char arr[] = "Hello ttzs";
//	int len = my_strlen(arr);//char* 的指针；可以变得更加安全
//	printf("%d\n", len);
//	return 0;
//}

//编程常见的错误：
//1.编译型错误:不合乎语法规则(;）——编译器爆出来的——>最简单的——看错误信息进行解决；
//2.链接型错误:链接期间  msvc test.c -o test.exe    —找不到名字—标识符不存在、名字不对应（拼写错误）等等——无法解析的外部函数；双击无法查到位置：C+F进行搜索
//3.运行时错误:最难解决的——>调试解决——最困难的

//积累经验——bug错误
//做一个有心人，不断积累

int add(int a, int b)
{
	return a + b;
}
int main()
{
	int  a = 0;
	int b = 10;
	int c = add(a, b);//编译器给函数加_进行修改
	printf("")
		return 0;
}