#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//指针

//本质上，指针是内存中最小内存单元（1byte――>1个字节）的编号，即地址
//内存单元的编号――>地址<――>指针
//指针就是地址，就是编号

//口语中，指针，通常是指针变量，通常用来存储内存地址的变量，就是一个变量

//内存的地址，不用存储，是硬件来生成的
//一个内存单元是一个字节；1bit太小了，太浪费地址|1kb太大，空间浪费

//int main()
//{
//	int a = 10;//a是整型的变量，占用四个字节的内存空间
//	//&a->起始地址
//	//地址也是值
//	int* pa=&a;
//	//pa是一个指针变量，用来存放地址
//	return 0;
//}

//地址的产生
// 32位机器――>32根地址线――>每根地址线产生高（1）低（0）压――>2^32个地址|字节->4GB|| 地址需要4个字节（1个bite――>0|1）
// 64位机器――>4EB|| 地址需要8个字节（1个bite――>0|1）
// 指针的大小在32位平台就是4个字节，在64位平台上就是8个字节
// X86意味着是32位的环境
//指针变量存放的就是地址；通过这个地址，就可以找到一个内存单元
//地址是唯一标识一块地址空间的
//int main()
//{
//	char* p = NULL;
//	short* ps = NULL;
//	int* pi = NULL;
//	double* pd = NULL;
//	//sizeof返回的值是无符号整型 unsigned int
//	//zu__>准确的
//	printf("%zu\n",sizeof(p));
//	printf("%zu\n", sizeof(ps));
//	printf("%zu\n", sizeof(pi));
//	printf("%zu\n", sizeof(pd));
//
//
//	return 0;
//}
//

//指针和指针类型

////类型是一种视角
//int main()
//{
//	int a = 0x11223344;//两个16进制位为一个字节（8个比特位|二进制位）|0x_16进制
//	//0001|0001|0010|0010|
//	/*int* pa = &a;
//	*pa = 0;*/
//	char* pa = (char*)&a;
//	//会报警告;;强制类型转换；；；可以存地址
//	*pa = 0;
//	//但是，指针类型的差异不决定指针的大小，决定了指针再被解引用的时候访问几个字节
//	//如果是int* 的指针，解引用访问4个字节
//	//如果是char*的指针，解引用访问1个字节
//	//推广到其他
//	return 0;
//}

////进制只是表示相同数字的不同表现形式
//int main()
//{
//	int a = 0x11223344;
//	//100
//	//0x64-十六进制
//	//0144-八进制
//	//110 0100-二进制
//	int* pa = &a;
//	char* pc =(char*) &a;
//	printf("pa  =%p\n", pa );
//	printf("pa+1=%p\n", pa+1);
//	printf("pc  =%p\n", pc );
//	printf("pc+1=%p\n", pc+1);
//
//	return 0;
//}

//int main()
//{
//	int a = 0;
//	int* pi = &a;
//	float* pf = &a;
//	//int* 和float* 能不能混用呢？
//	//不能
//	*pi = 100;
//	*pf = 100;
//	//尽管int* 和float*解引用的空间大小一样以及补偿一样
//	//但是int  float 的数据存储形式不同
//	//
//	return 0;
//}
//区别：指针的内存大小和通过指针访问的内存的大小

//野指针――指针未初始化；数组越界访问；指针指向的空间释放
//int main()
//{
//	int* p;//*p没有明确的指向，没有进行初始化
//	//一个局部变量没初始化，其的空间是一个随机地址：0xcccccccc
//	*p = 10;//可以找到该随机地址，但是无法访问且无法修改
//	//即：非法访问，这里的*p就是野指针
//
//}
//int main()
//{
//	int arr[10] = { 0 };
//	int* p = arr;//&arr[0]
//	for (int i = 0; i <= 10; i++)
//	{
//		*p = i;//越界访问 ――>超出arr的范围
//	}
//
//	return 0;
//}
//int* test()
//{
//	int a = 10;
//	return &a;
//}
//
//int main()
//{
//	int* p = test();//可以获得地址，可以找到这块内存，但是无法访问和修改权限
//	return 0;
//}
// 
// 
//如何避免野指针 的一般出现？
//及时赋值;
// 小心指针越界
//初始化成，及时空指针；
// 避免返回局部变量的地址
// 指针使用前要检查啊有效性
// 
// 
// 
//int main()

//{
//	int a = 10;
//	int* p = &a;
//	*p = 20;
//	//合法
//
////----------------
//	int* b = NULL;//NULL->0;
//	*p = 20;
//	//写入访问权限冲突；
//	//0地址是不能访问的
//	if (*p != NULL)//(*p)也可以通过，但是不推荐
//	{
//		*p = 100;//检测机制――>ok
//	}
////只能避免空指针；无法判断其他形式的野指针
//	return 0;
//}

//
//int* test()
//{
//	int a = 10;
//	return &a;
//}/此后这块空间的权限不在，但内存空间还在，数据有可能还在里面
//int main()
//{
//	int* p = test();
//	printf("haha");
//	printf("haha");
//	if (*p != NULL)
//	{
//		printf("%d", *p);//不一定永远都是10；
//	}
//	return 0;
//}
//小心敬慎的野指针，检查等等


//指针运算
//指针加减整数
//#define N 5
//int main()
//{
//	float arr[N];
//	float* p;
//	for (p = &arr[0]; p < &arr[N];)//初始化||arr[N]已经不在数组内了||指针的关系运算||只是借用地址进行比较，不算数组越界
//	{
//		*p++ = 0;//先运算后++；
//		//*p=0|||p++
//	}//将数组赋值为为0；
//	//*p++--->*p|p++||地址++
//	//（*p）++----> p指向的内容++
//	return 0;
//}
//
//int main()
//{
//	int arr[10] = { 1 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//数组的小标写法
//	/*for (i = 0; i < sz; i++)
//	{
//		arr[i]++;
//	}*/
//	//指针形式
//	int* p = arr;
//	for (; p < &arr[sz];)
//	{
//		++*p++;
//		//*(p+i)=1;
//	}
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d", arr[i]);
//	}
//}

//指针-指针
//不是所有的指针都能相减
////指向同一块空间的指针才能详见――>可能偏爱数组
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%d", &arr[9] - &arr[0]);//|指针减去指针|(绝对值)得到的是指针和指针之间的元素的个数
//	//不同类型的指针相减――>没有意义
//	return 0;
//}
//版本一
//int my_strlen(char* str)
//{
//	int count = 0;
//	while (*str != '\0')
//	{
//		str++;
//		count++;
//	}
//	return count;
//}
// 方法二：
//方法三：指针减去指针的办法
//int my_strlen(char* str)
//{
//	char* start = str;
//	while (*str != '\0')
//	{
//		str++;
//	}
//	return (str-start);
//}
//int main()
//{
//	int len = my_strlen("abcdef");
//	printf("%d\n",len);
//	return 0;
//}
//指针+指针？没有意义

//类比：日期-+天数|日期―日期|但是日期+日期没有意义

//关系运算――比较大小
//int main()
//{
//	float arr[5] = { 2,2,2,2,2 };
//	float* p = &arr[5];
//	/*for (; p > &arr[0];)
//	{
//		*--p = 0;
//	}*/
//	for (p = &arr[4]; p >= &arr[0]; p--)
//	{
//		*p = 0;
//	}//更好理解；但是标准不保证可行，尽管绝大部分编译器可以完成任务
//	//标准：允许指针跟指向数组后面内存的指针进行比较；但是不允许跟数数组之前的元素进行比较
//	// 
//	//指针题目一定要画图，解决
//	return 0;
//}

//指针和数组
//数组一组相同类型元素的集合
//指针变量是一个变量，存放的是地址
//
//int main()
//{
//	int arr[10] = { 0 };
//	//arr是首元素的地址；
//	//%arr[0]
//	int* p = arr;
//	//通过指针来访问数组
//	//但数组就是数组，指针就是指针
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int i = 0;
//	for (i = 0; i < sz; i++)
//	{	//arr[i]---->*(arr+i)
//		//p+i=&arr[i]=arr+i;
//		printf("%d ",*(p+i));
//	}
//	return 0;
//}


//指针的初始化
//int main()
//{
//	int a = 10;
//	int p = &a;//存储的是地址的值，而非指针的权限
//	printf("%o",p);
//}


//二级指针
//int main()
//{
//	int a = 10;//4字节
//	int* p = &a;//4字节存放整型变量的起始地址――>一级指针变量（一次解引用就能找到）
////p指向的对象是int类型 指针类型 
//	int** pi = &p;//4字节||ppa是一个二级指针变量；需要两次连续的解引用的权限
////pi指向的对象整体是类型int* 指针类型
//	int*** pt = &pi;//高级指针
//	printf("%d",**pi);
//	printf("%d", ***pt);
//
//	return 0;
//}

//二级指针是用来存放一级指针变量的地址，不是地址的地址（不存在）

////指针数组――>存放指针的数组
//int main()
//{
//	//int a = 10;
//	//int b = 20;
//	//int c = 10;
//	//int arr[10];
//	//int* pa = &a;
//	//int* pb = &b;
//	//int* pc = &c;
//	//int* parr[10] = {&a,&b,&c};//存放指针的数组――>指针数组
//	//int i = 0;
//	//for (i = 0;i<3;i++)
//	//{
//	//	printf("%d  ",*(parr[i]));
//	//}
//	//用指针数组――>模拟出来一个二维数组
//	//int arr[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6};
//	////1 2 3 4
//	////2 3 4 5
//	////3 4 5 6
//	//int i = 0;
//	//for (i= 0;i<3;i++)
//	//{
//	//	for (int j =0;j<4;j++)
//	//	{
//	//		printf("%d  ", arr[i][j]);
//	//	}
//	//	printf("\n");
//	//}
//	int arr1[4] = { 1,2,3,4 };
//	int arr2[4] = { 2,3,4,5 };
//	int arr3[4] = { 3,4,5,6 };
//	int* parr[3] = { arr1,arr2,arr3 };
//	for (int i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for(j = 0;j<4;j++)
//		{ 
//		printf("%d ",*(parr[i]+j));//模拟二维数组|*(parr[i]+j)--->parr[i][j]
//		}
//		printf("\n");
//	}
//
//	return 0;
//}

