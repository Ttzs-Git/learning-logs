#include<stdio.h>
//release 版本会进行优化
//代码大小会小很多
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", arr);
//	printf("%p\n", &i);
//	//for (i = 0; i <= 12; i++)
//	//{
//	//	arr[i] = 0;
//	//	printf("heheh\n");
//	//}//该代码跟环境有很大关系
//	return 0;
//}
//栈区原本的规则是先使用高地址，在使用低地址
//x86的条件下
//release：只打印13次;i的地址比arr的地址低
//debug：死循环;i的地址比arr的地址高
//内存的开辟方式变化
//改变代码的效果
//rlease可能需要gcc做一些调整
//但release 的优化是有限的——故意的死循环

//数据在内存中如何存储的？？？
//C语言的数据类型
//c99中引入的long long
//C语言规定：sizeof(long)>sizeof(int)
//               4|8         4
//               32|64位
// 类型的意义：
// 1.使用这个类型，决定了开辟空间的大小
// 2.看待的内存的不同视角——存储数据的方式


//整形家族
// char
//		char 到底是un-char还是char：标准是未定义的，取决于编译器的实行
//     unsigned char
//		 signed char
// 
// 字符本质是ascii码值，整形家族，所以划分到
//short
//		unsigned short [int]
//		  signed short [int]——> int 
//int 
//		unsigned int 
//		  signed int<---->int 等价
//long
//		unsigned long[int]
//		  signed long[int]---->long
//long long 
//		unsigned long long[int]
//		  signed long long[int]-----long long 


//生活中一些数据是没有负数的，e.g.身高|体重|长度——>unsigned int ;
//int a=10;
//a是一个整数，有符号的整形，一个整形是4个字节=32bits
//    0                                    0000000000000000000000000000000
//  高位就是符号位：0-->正数；1->表示负数；；不参与数值据绝对值的表现
//有正负数——(signed )int

//浮点型家族——小数
//float  精度低，存储的数值范围较小
//double精度高，存储的数值范围更大

//构造类型——自定义类型（自己可以创造处新的类型）
//数组类型   int arr[5] ---int[5]  ;  int arr[8]---int [8];;char arr2[5]----char[5]
//结构体类型struct
//枚举类型eum
//联合类型union

//指针类型
//int* pi
//char* pc
//float* pf
//void* pv

//空类型——无类型
//void：函数返回值类型|函数的参数|指针类型

//void test()
//{//函数无返回值  函数不需要传任何参数
//	//形参表中无void ，传参无影响；传而不用
//	//形参表中有void，传参会有警告，但是不起强作用
//	printf("heheh\n");
//}
//
//int main()
//{
//	test(1);
//	return 0;
//}
//
////void* q;指针具有特殊性
////int* p;

//整形在内存中如何存储
//数值有不同的表示形式
//二进制|八进制|十进制|十六进制
//十进制——21
//二进制——0b10101
//八进制——025
//十六进制--0x15

//如何快速计算：不同位的权重

////整数的三种二进制表示：
//// 原码：直接通过正负表示出来的二进制序列
//// 反码：原码的符号位不变，其他位，按位取反
//// 补码：反码+1
////正整数的原码反码补码相同
////负整数原码、反码、补码是需要计算的
////
//int main()
//{
//	int a = 20;
//	//20——32个bit位
//	//000····10100
//	// 0x00 00 00 14
//	//000····10100
//	//000····10100
//
//	int b = -10;
//	//1000···1010
//	// 0x80 00 00 0 a
//	//1111···0101
//	// 0xff ff ff f5
//	//1111···0110
//	// 0xff ff ff f6
//	//4个二进位写成一个16进制位
//	
//	//符号位+数值位
//	return 0;
//}

//只要是整数，内存存的是补码的二进制序列
//原因：可以符号位和数值进行统一处理
//同时，加法和减法也可以统一处理——CPU中只有加法器
//补码和原码的相互转换，其运算的过程是统一的，不需要额外的硬件电路
//补码——符号位不变，其他取反，+1得到原码
//取反+1得到了统一

//例如：1-1
//1+（-1）
//原码计算：0···0001+1···0001=1···0002无法计算
//补码计算：0···0001+1···1111=0···0000（多出了的1位丢了）就是0

//C++
//C语言  C语言实现简单的数据结构
//c++ c++stl 高阶的数据结构 计算机网络（网络协议+网络编程）
//linux（操作系统+系统编程）+数据库（MySQL）+实战项目

//Java：
//C JavaSE java 实现简单的数据结构+高阶数据结构+javaee初级（javaweb 操作系统 计算机网络 linux）
//数据库mysql+javaee+实战项目

//测开：
//C JavaSE java 实现简单的数据结构+高阶数据结构+javaee初级（javaweb 操作系统 计算机网络 linux）
//数据库mysql+测开+实战项目

//450+
//对于408 解决60%左右

//为什么补码倒着存放呢？——大小端问题
// 内存中存的是二进制，只是顺序上的问题
//低地址    — —    高地址
//0x11 22 33  44
//存放的顺序？
//本质上，只要记得存放方式，在取出来，就可以
//以字节为单位讨论
//低地址 11 22 33 44——大端字节序存储——把一个数据的高位字节序的内容存放在低地址处；高低低高
//低地址 44 33 22 11——小端字节序存储——把一个数据的低位字节序的内容存放在低地址处；高高低低
//《深入计算机系统》
//大小端—灵感：格列夫游记
//数据在内存中的存储
//char只有1个字节，大小端之分
//short int float 有大小端之分

//大小端存放的原因？？？  取决于是硬件
//x86是小段模式
//KEILC51 是大端模式
//很多的ARM DSP小端
//ARM话可以由硬件决定是大端还是小段的
//
// 栈内存是先使用高地址在使用低地址
// 
// 
//百度2015年系统工程师：简述大端和小端字节序的概念；设计一个小程序判断机器的大小端
//int check()//很好的封装的函数
//{
//	int a = 1;
//	//0x00 00 00 01
//	//小端： 01 00 00 00
//	//大端： 00 00 00 01
//	//差异：第一个字节的数据有差异
//	return *(char*)&a;
//
//}
//int main()
//{
//
//	if (check())
//	{
//		printf("小端存储");
//	}
//	else {
//		printf("大端存放");
//	}
//	return 0;
//}

//内存中的最小访问的单位就是字节，不能再小了

////练习1
//int main()
//{
//	char a = -1;//-256;
//	//1000···0001
//	//1111···1110
//	//1111···1111
//	//char 会对数据进行截断
//	//11111111 -a
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d b=%d c=%d ", a, b, c);
//	//%d是打印有符号的整形; 
//	// 发生整形提升  
//	// 如果是有符号整形
//	// 检测符号位 
//	//如果是1，前面补1
//	//但依旧是补码
//	//
//
//	//如果是无符号
//	//高位补0
//
//	//思考:数字会改变
//	//跟大小端无关
//
//	return 0;
//}
////知识点：
////数据：00000000~11111111   内存中存放 512
////signed char：情况下，最高位是符号位
////			01 11 11 11——正数127		
////			10 00 00 00
////			11 11 11 11——补码——原码10 00 00 01 ——>-1
////			11 11 11 10                                 -2
////0			-127-	(-128)(直接解析成) -	(-127)-		(-1)
////00000000	~		10 00 00 00-					11111111
//
////unsigned char 没有符号位，都是数值位；
////取值范围：0--255
//
////如果是short：16个bit位。。。。
////unsined short：0-65535
////signed short:-32768-32767
//
////解释：
////在当前编译环境下，char=signed char 
////猜测：在计算机眼中，只有二进制；数据无论输入什么，转化成二进制补码存储；数据类型决定看待这些数据的方式|角度——进行输出   ；存储时会截断，输出时会加长
////

////练习二
//int main()
//{
//	char a = -128;
//	//char:-128--127
//	//a:1000 0000
//	//1111····1000 0000 提升按照类型进行提升
//	printf("%u\n", a);
//	//u-打印无符号整数
//	//无符号数
//	return 0;
//}

////练习三
//int main()
//{
//	char a = 128;//-128-127；128实际上存不下
//	printf("%u\n", a);
//	printf("%d\n", a);
//
//	//先输出整数的int
//	//截断
//	//提升——根据数据类型进行补位
//	//打印的原则
//	return 0;
//}

//////练习四
//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	return 0;
//}
////-10
////类型变化，存储的补码不变
////按照补码形式进行运算，最后格式化为有符号整数

//// 练习5
//#include<Windows.h>
//int main()
//{
//	unsigned int i;//初始化时i>=0
//	for (i = 9; i >= 0; i--)//其实i》=0恒成立————> 死循环
//	{
//		printf("%u\n", i);
//		Sleep(1000);//休眠1000ms
//	}
//	return 0;
//}
//
//// 练习6
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));
//	//strlen 关注是求字符串的长度   字符‘\0’（数字0）之前出现多少字符  ——>不包含0
//	return 0;
//}
//// arr[i]---> char  -128-127
////char的加法回环：0-127-  （-128 ）  -  （-127） -  （-1 ） -0  ——> 截断的原因和补码的原因
// char  -当前msvc|大部分的编译器是signed char


////练习6
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)//恒成立的条件
//	{
//		printf("Hello World\n");
//	}
//	return 0;
//}

//小心死循环
//
//// 模拟实现strlen函数
//#include<string.h>
//int main()
//{
//	if (strlen("abc") - strlen("abcdef") >= 0)
//		//返回值  size_t-  unsigned int 
//		//无符号数 的小心！！！
//		//如果是my_strlen 就不同
// //直接进行比较：强制类型转化|直接比较
//		printf(">");
//	else
//		printf("<");
//
//}
// 有符号数+无符号数； 有符号数——>无符号数


//浮点型在内存中是如何存储中的呢？
//浮点数的范围在float.h中定义
//整数的范围在limits.h中定义

int main()
{
	int n = 9;
	float* pfloat = (float*)&n;
	printf("n的值是：%d\n", n);
	printf("pfloat的值是： %f\n", *pfloat);
	*pfloat = 9.0;
	printf("num=%d\n", n);
	printf("pfloat=%f", *pfloat);
	return 0;
}
//整数和浮点数的存储方式不同
//浮点数存储规则
//根据IEEE电器和电子工程协会754：
// 任何一个二进制的浮点数都可以表示下面的形式:
// (-1)^S*M*2^E
// (-1)^S表示一个符号位，当S=0，V为正数
// M表示有效数字，>=1,<2
// 2^E表示指数位
//

//任何一个数——>小数点前后都转化成二进制数
// ——>浮点数  科学计数法：同时指数转化成二进制数

//纯整数部分：短除倒取余
// 纯小数部分：短除正取余
//float 32bits
///double 64bits
//浮点数有可能无法精确保存，丢了部分

