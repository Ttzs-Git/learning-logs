# 结构、联合、枚举
## 一、结构体
### 结构体的定义
~~~c
struct 结构体类型名
{
    数据类型 成员变量名;
};
~~~
> 此处仅仅是进行结构体的声明，而非定义
> 结构体中的数据类型可以是结构体——嵌套结构体，也可以是枚举类型，也可以是数组，还可以是函数指针

### typedef起别名
~~~c
typedef 结构体类型名 别名;
~~~
~~~c
//第一类
struct x
{
    int a;
}；
typedef struct x  x;
~~~
~~~c
//第二类
typedef struct x
{

}x;
~~~
### 结构体变量
~~~c
struct 结构体类型名 结构体变量名;
~~~
> 结构体变量的内存大小至少是所有成员的占用的内存总和
> 由于“内存对齐”等原因，可能比所有成员的占用的内存总和大
~~~c
//第一类：先声明再定义
struct x
{
    int a;
};//此处也可以别名一下
struct x x1;
~~~

~~~c
//第二类：直接定义
struct x //如果是只定义一个 x1,此处的x可以省略
{
    int a;
}x1;
~~~

### 结构体的赋值
~~~c
//第一类：定义时赋值
X x1={ };//此处类似于数组的定义：没有就不写，默认为0
X x2=x1;//相同类型的结构体间的赋值
~~~
~~~c
//第二类：定义后赋值
X x1;
x1.a=1;//通过点运算符进行访问成员变量
X x2;
x2=x1;//相同类型的结构体间的赋值
~~~
> 点运算符前必须是指针变量，而不能是结构体的类型
> 除了赋值外，我们无法对于结构体的整体进行操作

### 结构体指针
~~~c
struct 结构体类型名 * 结构体指针名;
结构体指针名 = &结构体变量名;
~~~

> 通过结构体指针可以对结构体成员进行访问
~~~c
X x1;
X *P =&x1;
p——>a=1;
~~~

### 结构体数组
~~~c
struct 结构体类型名 结构体数组名[数组大小];
~~~

访问结构体数组的某个结构体元素的方法
~~~c
结构体数组名[下标].成员变量名;
~~~
~~~c
（结构体数组名+i）——>成员变量名;
~~~
~~~c
（*（结构体数组名+i））.成员变量名;
~~~
> 通常使用的是第一种，少数使用第二种

### 向函数传递结构体
1. 传结构体的成员
2. 传结构体变量
> 上述两种都只是传值，不会改变实际结构体中的值
3. 传结构体指针

## 二、联合
> 共用体
> 联合：定义的一堆类型中，同一时刻只有一个成员变量有效，其他成员变量无效
### 联合的声明
语法：
~~~c
union 联合名
{
    数据类型 成员变量名1;
    数据类型 成员变量名2;
};
~~~
### typedef起别名
~~~c
typedef union   联合名 别名;
~~~

> 内存大小至少是成员所需最大的内存
> 特征：空间共享，后者有效
### 联合变量
~~~c
union 联合名 联合变量名;
~~~

> 访问方式：点运算符
~~~C
联合变量名.成员变量名;
~~~
> 联合无法整体访问和输出，初始化时，只能初始化第一个成员
>联合无法作为函数的参数

## 三、枚举
>枚举：一一列举
### 枚举的声明
语法：
~~~c
enum 枚举名 
{
    枚举值1,
 };
~~~
> 枚举类型同样可以使用typedef起别名
> 若未定义枚举值，系统会默认枚举值对应一个默认整形值，从0开始，后面是前面+1
> 若定义了部分，则未定义部分是最后一个定义值+1
### 枚举变量
语法：
~~~c
enum 枚举名 枚举变量名;
~~~

### 枚举变量的赋值
> 可以用枚举类型的数据或者整形数据进行赋值，但是输出只能输出整形

## 四、链表
> 链表：一种特殊的线性表，可以插入和删除数据，但是不能随机访问，只能顺序访问
>结点：数据域+指针域
> 链表：头指针+∑结点
### 链表的定义
 ~~~c
 struct node
{
    int data;
    struct node *next;
};
~~~
### 链表的基本操作
#### 链表的建立——批量存入信息
##### 头插法
##### 序插法
##### 定位法
##### 尾插法



#### 链表的打印
1.使用工作指针p，静态打印
~~~c
p=head;
while(p!=NULL)
{
    printf("%d",p->data);
    p=p->next;
}
~~~

#### 链表的删除

#### 链表的插入